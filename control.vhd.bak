library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;

entity control is

   generic (N:integer:=32);
   port(Q : in std_logic_vector(N-1 downto 0);
	     Q_new_new: out std_logic_vector(N downto 0)
			);
			
end control;
architecture behavioral of control is

component comparator is
   generic (N: integer:= 32);
   port( M_32bit : in std_logic_vector(N-1 downto 0);
         Q_32bit : in std_logic_vector(N-1 downto 0);
		   greater,less,equal: out std_logic);
			
end component comparator;

component mod_operator is
   generic (N:integer:=32);
   port( M : in std_logic_vector(N-1 downto 0);
	      Q : in std_logic_vector(N-1 downto 0);
			remainder :out std_logic_vector(N downto 0)
	);
end component mod_operator;
signal Q_new:  std_logic_vector(N downto 0);
constant divisor: std_logic_vector(31 downto 0) :="00000000000000000000000000100000";
shared variable Q_new1: std_logic_vector(N downto 0);
begin
   
m2: mod_operator port map(Q,divisor,Q_new1);


process(Q)
begin

if Q(N-1 downto 0)> divisor then
   Q_new<= Q_new1;
else 
   Q_new<='0' & Q;
end if;
  end process;
  Q_new_new<=Q_new;
 end behavioral;